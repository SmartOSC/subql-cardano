# To improve query performance, we strongly suggest adding indexes to any field that you plan to filter or sort by
# Add the `@index` or `@index(unique: true)` annotation after any non-key field
# https://academy.subquery.network/build/graphql.html#indexing-by-non-primary-key-field

enum EventType {
  SendPacket
  RecvPacket
  WriteAck
  AcknowledgePacket
  TimeoutPacket
  TimeoutPacketOnClose

  ChannelOpenInit
  ChannelOpenTry
  ChannelOpenAck
  ChannelOpenConfirm
  ChannelCloseInit
  ChannelCloseConfirm
  ChannelClosed

  ConnectionOpenInit
  ConnectionOpenTry
  ConnectionOpenAck
  ConnectionOpenConfirm

  CreateClient
  UpdateClient
}

enum ChannelStateType {
  Uninitialized
  Init
  TryOpen
  Open
  Closed
}

enum ChannelOrderType {
  None
  Unordered
  Ordered
}

enum MsgType {
  SendPacket
  RecvPacket
  AcknowledgePacket
}

type ChannelCounterparty @jsonField(indexed: false) {
  portId: String!
  channelId: String! 
}

type ConnectionCounterparty @jsonField(indexed: false) {
  clientId: String!
  connectionId: String!
  prefix: String!
}

type ClientUncheckedRational @jsonField(indexed: false) {
  numerator: BigInt!
  denominator: BigInt!
}

type Height @jsonField(indexed: false) {
  revisionNumber: BigInt!
  revisionHeight: BigInt!
}

type LeafOpSchema @jsonField(indexed: false) {
  hash: BigInt!
  prehashKey: BigInt!
  prehashValue: BigInt!
  length: BigInt!
  prefix: String!
}


type ProofSpec @jsonField(indexed: false) {
  leafSpec: LeafOpSchema!
  innerSpec: InnerSpec!
  maxDepth: BigInt!
  minDepth: BigInt!
  prehashKeyBeforeComparison: Boolean!
}

type InnerSpec @jsonField(indexed: false) {
  childOrder: [BigInt]
  childSize: BigInt!
  minPrefixLength: BigInt!
  maxPrefixLength: BigInt!
  emptyChild: String!
  hash: BigInt!
}

type CardanoTransfer @entity {
  id: ID!
  blockHeight: BigInt!
  slot:BigInt!
  sender: String!
  receiver: String!
  sequence: String!
  srcPort: String!
  srcChannel: String!
  dstPort: String!
  dstChannel: String!
  connectionId: String!
  msgType: MsgType!
  amount: String!
  denom: String!
}

type EventAttribute @jsonField(indexed: false) {
  key: String!
  value: String
}

type ConnectionVersion @jsonField(indexed: false) {
  identifier: String!
  features: [String]
}

type Event @entity {
  id: ID!
  blockHeight: BigInt!
  txHash: String!
  type: EventType!
  eventAttributes: [EventAttribute]! # Store a list of JSON objects
}

type Client @entity {
  id: ID!
  chainId: String!
  trustLevel: ClientUncheckedRational!
  trustingPeriod: BigInt!
  unbondingPeriod: BigInt!
  maxClockDrift: BigInt!
  frozenHeight: Height!
  latestHeight: Height!
  proofSpecs: [ProofSpec]!

}

type Connection @entity {
  id: ID!
  clientId: String!
  versions: [ConnectionVersion]!
  state: String!
  counterparty: ConnectionCounterparty!
  delayPeriod: String! 
}

type Channel @entity {
  id: ID!
  state: ChannelStateType!
  ordering: ChannelOrderType!
  portId: String!
  counterparty: ChannelCounterparty!
  connectionHops: String!
  version: String
}

type CardanoIbcAsset @entity {
  id: ID!
  accountAddress: String!
  denom: String!
  voucherTokenName: String!
  connectionId: String!
  srcPort: String!
  srcChannel: String!
  dstPort: String!
  dstChannel: String!
  path: String!
}